<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <title>Quantum LaTeX Flashcards - Fixed Math</title>
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            startup: { pageReady: () => { return MathJax.startup.defaultPageReady(); } }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root { --bg: #0f111a; --card: #1a1c29; --text: #e0e6ed; --accent: #00f2ff; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); padding: 20px; display: flex; flex-direction: column; align-items: center; }
        #app { max-width: 850px; width: 100%; background: var(--card); padding: 30px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.6); }
        h1 { color: var(--accent); border-bottom: 1px solid #333; padding-bottom: 10px; }
        #content { font-size: 1.3rem; line-height: 2; margin: 25px 0; }
        /* Styl pro skrytý vzorec nebo slovo */
        .gap { background: #333; color: transparent !important; border-bottom: 2px solid var(--accent); cursor: help; user-select: none; transition: all 0.2s; }
        .gap * { visibility: hidden; } /* Schová i MathJax render uvnitř */
        
        .gap.revealed { background: transparent; color: #ff00ff !important; border-bottom: none; }
        .gap.revealed * { visibility: visible; color: #ff00ff !important; }

        .controls { display: flex; gap: 10px; margin-top: 20px; }
        button { flex: 1; padding: 15px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1.1rem; }
        #btn-next { background: var(--accent); color: #000; }
        #btn-know { background: #4caf50; color: white; display: none; }
        #btn-dont { background: #f44336; color: white; display: none; }
        
        table { width: 100%; margin-top: 30px; border-collapse: collapse; font-size: 0.85rem; }
        th, td { border: 1px solid #333; padding: 10px; text-align: left; }
    </style>
</head>
<body>

<div id="app">
    <h1 id="title">Načítání...</h1>
    <div id="content"></div>
    
    <div class="controls">
        <button id="btn-next" onclick="revealGaps()">Pokračovat</button>
        <button id="btn-know" onclick="updateScore(1)">Umím</button>
        <button id="btn-dont" onclick="updateScore(-1)">Neumím</button>
    </div>

    <table id="stats-table">
        <thead><tr><th>Téma</th><th>Slov</th><th>K</th><th>Frakce</th></tr></thead>
        <tbody></tbody>
    </table>
</div>

<script>
    let currentPath = '';
    let db = JSON.parse(localStorage.getItem('q_db')) || {};
    let fileList = [];

    async function init() {
        const res = await fetch('data.json');
        fileList = await res.json();
        await loadNew();
    }

    async function loadNew() {
        let minF = Infinity;
        let candidates = [];

        fileList.forEach(path => {
            if (!db[path]) db[path] = { known: 1, total: 0, title: path };
            let f = db[path].total > 0 ? (db[path].known / db[path].total) : 0;
            if (f < minF) { minF = f; candidates = [path]; }
            else if (f === minF) { candidates.push(path); }
        });

        currentPath = candidates[Math.floor(Math.random() * candidates.length)];
        const text = await (await fetch(currentPath)).text();
        renderPage(text);
    }

    function renderPage(text) {
        const titleMatch = text.match(/\\popis\{([^}]+)\}/);
        db[currentPath].title = titleMatch ? titleMatch[1] : currentPath;
        
        let bodyText = text.replace(/\\popis\{[^}]+\}/, '').trim();
        
        // TOKENIZER: Klíčová část. Rozdělí na slova NEBO bloky $...$
        let tokens = bodyText.match(/(\$[^\$]+\$|[^\s]+)/g) || [];
        db[currentPath].total = tokens.length;

        let indices = Array.from(Array(tokens.length).keys()).sort(() => Math.random() - 0.5);
        let gapped = indices.slice(0, db[currentPath].known);

        let html = tokens.map((t, i) => {
            if (gapped.includes(i)) {
                return `<span class="gap">${t}</span>`;
            }
            return t;
        }).join(' ');

        document.getElementById('title').innerText = db[currentPath].title;
        document.getElementById('content').innerHTML = html;
        
        // Schovat tlačítka umím/neumím
        uiState(false);
        updateTable();

        // MATHJAX TRIGGER: Vykreslit nově přidané vzorce
        if (window.MathJax) {
            MathJax.typesetPromise();
        }
    }

    function revealGaps() {
        document.querySelectorAll('.gap').forEach(el => el.classList.add('revealed'));
        uiState(true);
        if (window.MathJax) MathJax.typesetPromise();
    }

    function updateScore(v) {
        let e = db[currentPath];
        e.known = Math.max(1, Math.min(e.total, e.known + v));
        localStorage.setItem('q_db', JSON.stringify(db));
        loadNew();
    }

    function uiState(revealed) {
        document.getElementById('btn-next').style.display = revealed ? 'none' : 'block';
        document.getElementById('btn-know').style.display = revealed ? 'block' : 'none';
        document.getElementById('btn-dont').style.display = revealed ? 'block' : 'none';
    }

    function updateTable() {
        const tb = document.querySelector('#stats-table tbody');
        tb.innerHTML = '';
        for (let p in db) {
            let info = db[p];
            let f = info.total > 0 ? (info.known / info.total).toFixed(2) : "0.00";
            tb.innerHTML += `<tr><td>${info.title}</td><td>${info.total}</td><td>${info.known}</td><td>${f}</td></tr>`;
        }
    }

    init();
</script>
</body>
</html>
